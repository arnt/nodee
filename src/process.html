<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html lang=en><head><title>Process documentation</title>
<link rel=stylesheet href="udoc.css" type="text/css">
<link rel=generator href="http://archiveopteryx.org/udoc/">
</head><body>
<h1 class="classh">Class Process.</h1>
<p class="text">Inherited by <a href="zkclient.html">ZkClient</a>.
<p class="text">Constructs a Process to look out for some child process.
<p class="text">The caller manually has to hand ownership over to <a href="init.html">Init</a>.
<p class="text">Most of Process manages information about the process; very few functions can be used to change the process.
<p class="text"><a href="process.html#fork">fork()</a> forks and starts the class. <a href="process.html#assignUidGid">assignUidGid()</a> assigns otherwise unused IDs for the process, so that no two services use the same UID or GID.
<p class="text"><a href="process.html#setCurrentRss">setCurrentRss()</a> and <a href="process.html#setPageFaults">setPageFaults()</a> are used by the <a href="chorekeeper.html">ChoreKeeper</a> to store information for the later use by the <a href="chorekeeper.html">ChoreKeeper</a> itself.
<p class="text">There's a testing helper called <a href="process.html#fakefork">fakefork()</a>, which should never be used in production, and a static function called <a href="process.html#launch">launch()</a> to launch a new process, including download helpers if necessary.
<p class="text">The remaining functions all return information, from <a href="process.html#pid">pid()</a> and <a href="process.html#gid">gid()</a> to <a href="process.html#spec">spec()</a>.
<p class="text">Implementation note: This class never kills or otherwise affects the child process, it merely records information about it. 
<h2 class="functionh"><a name="Process"></a>Process::Process( const Process &amp; other )</h2>
<p class="text">Constructs a copy of <i>other.</i> Deep copy, no sharing. 
<h2 class="functionh">Process::Process( int uid, int gid )</h2>
<p class="text">Constructs a Process without any <a href="serverspec.html">ServerSpec</a> and with <a href="process.html#uid">uid()</a> <i>uid</i> and <a href="process.html#gid">gid()</a> <i>gid.</i>
<p class="text">This is a helper for Script, which needs to <a href="process.html#start">start()</a> using those IDs. 
<h2 class="functionh">Process::Process()</h2>
<p class="text">Constructs a naked, invalid Process.
<p class="text">This is basically not useful. The unit tests use it, but it can't really be used in anger. 
<h2 class="functionh"><a name="assignUidGid"></a>void Process::assignUidGid()</h2>
<p class="text">Picks otherwise unused UID and GID for this process. 
<h2 class="functionh"><a name="currentRss"></a>int Process::currentRss() const</h2>
<p class="text">Returns the recorder RSS size, in kbytes 
<h2 class="functionh"><a name="fakefork"></a>void Process::fakefork( int fakepid )</h2>
<p class="text">Sets the object's state to look as though it has forked and the child's pid is <i>fakepid.</i> Used only for testing. 
<h2 class="functionh"><a name="fork"></a>void Process::fork()</h2>
<p class="text">Fork a child process, redirect its stdin/stdout/stderr appriopriately, and call <a href="process.html#start">start()</a> in the child. 
<h2 class="functionh"><a name="gid"></a>int Process::gid() const</h2>
<p class="text">Returns the GID used by this child, or 0 if the Process is not <a href="process.html#valid">valid()</a>. In theory, even <a href="process.html#valid">valid()</a> processes may run as root, but in practice that should not happen. 
<h2 class="functionh"><a name="handleExit"></a>void Process::handleExit( int status, int signal )</h2>
<p class="text">Notifies this object that it's process is gone, and how.
<p class="text"><i>status</i> is the exit status reported by the process (0 for successful exit) and <i>signal</i> is the signal that caused the process to terminate, if any. I assume that the signal is 0 if no signal intervened, but I haven't checked that.
<p class="text"><a href="init.html">Init</a> will check whether the Process is <a href="process.html#valid">valid()</a> after calling this, and delete the Process if not. 
<h2 class="functionh"><a name="launch"></a>static void Process::launch<span class=nobr>( const <a href="serverspec.html">ServerSpec</a> &amp; what,</span> <span class=nobr><a href="init.html">Init</a> &amp; init )</span></h2>
<p class="text">Launches a new Process based on <i>what,</i> managed by <i>init.</i> Returns quickly; the new Process will go on its way.
<p class="text">This may/will also start some helper processes to download and/or install the software specified by <i>what.</i> 
<h2 class="functionh"><a name="operator="></a>void Process::operator=( const Process &amp; other )</h2>
<p class="text">Makes this Process into an exact copy of <i>other.</i> 
<h2 class="functionh"><a name="operator=="></a>bool Process::operator==( const Process &amp; other )</h2>
<p class="text">Returns true if this Process and <i>other</i> refer to the same actual process, and false if not.
<p class="text">This means that all invalid processes are equal. Like it or not. 
<h2 class="functionh"><a name="pid"></a>int Process::pid() const</h2>
<p class="text">Returns the Process' unix pid, or 0 if there is no process.
<p class="text">There is no process before <a href="process.html#fork">fork()</a> or after <a href="process.html#handleExit">handleExit()</a>. 
<h2 class="functionh"><a name="recentPageFaults"></a>int Process::recentPageFaults() const</h2>
<p class="text">Returns how many faults have occured between the last and second-to-last calls to <a href="process.html#setPageFaults">setPageFaults()</a>. 
<h2 class="functionh"><a name="root"></a>string Process::root() const</h2>
<p class="text">Returns the root directory used by this Process. Automatically computed so as to be unique for each Process. 
<h2 class="functionh"><a name="setCurrentRss"></a>void Process::setCurrentRss( int r )</h2>
<p class="text">Records <i>r</i> as the current RSS, in kbytes 
<h2 class="functionh"><a name="setPageFaults"></a>void Process::setPageFaults( int f )</h2>
<p class="text">Records that <i>f</i> faults have occured since time immemorial. 
<h2 class="functionh"><a name="spec"></a><span class=nobr>const <a href="serverspec.html">ServerSpec</a> &amp;</span> Process::spec() const</h2>
<p class="text">Returns a reference to the <a href="serverspec.html">ServerSpec</a> that motivates the existence of this Process.
<p class="text">Note that the download, install and payload process have mostly identical <a href="serverspec.html">ServerSpec</a> instances. This is a either feature or a bug, depending on what you want it to happen or not happen. I lean towards regarding it as a feature, since download is motivated by the <a href="serverspec.html">ServerSpec</a> and should be accounted as such. 
<h2 class="functionh"><a name="start"></a>void Process::start()</h2>
<p class="text">Called in the child process to start the child's work. 
<h2 class="functionh"><a name="stop"></a>void Process::stop()</h2>
<p class="text">Stops the process, either by calling the script specified in the <a href="serverspec.html">ServerSpec</a> or by killing it. If the latter, then the kill is rude. Anyone who wants a pleasant kill can supply a suitable script. 
<h2 class="functionh"><a name="uid"></a>int Process::uid() const</h2>
<p class="text">Returns the UID used by this child, or 0 if the Process is not <a href="process.html#valid">valid()</a>. In theory, even <a href="process.html#valid">valid()</a> processes may run as root, but in practice that should not happen. 
<h2 class="functionh"><a name="valid"></a>bool Process::valid() const</h2>
<p class="text">Returns true if this Process represents a real unix process. 
<h2 class="functionh"><a name="destructor"></a>Process::~Process()</h2>
<p class="text">Destroys the object. Frees nothing.
<p class="text">Exists only because compilers tend to moan and wail if there is no constructor, and I like zero-warning code. 
<p class="rights">This web page based on source code belonging to <a href="http.html://arnt.github.com/nodee/">Arnt Gulbrandsen</a>. All rights reserved.</body></html>
