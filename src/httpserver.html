<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html lang=en><head><title>HttpServer documentation</title>
<link rel=stylesheet href="udoc.css" type="text/css">
<link rel=generator href="http://archiveopteryx.org/udoc/">
</head><body>
<h1 class="classh">Class HttpServer.</h1>
<p class="text">The HttpServer class provdes a HTTP server for Nodee's API. It expects to run in a thread of its own; the <a href="httpserver.html#start">start()</a> function does all the work, then exits.
<p class="text">I couldn't find embeddable HTTP server source I liked (technically plus BSD), so on the advice of James Antill, I applied some cut-and-paste. This server does not support the ASCII art from <a href="http://www.and.org/texts/server-http.">http://www.and.org/texts/server-http.</a> It's even more restrictive than Apache, and MUCH more restrictive than <a href="http://www.rfc-editor.org/rfc/rfc2616.txt">RFC 2616</a>.
<p class="text">The main purpose (I hesitate to say benefit) of these restrictions is to avoid allocating memory. Memory never allocated is memory never leaked.
<p class="text">The member functions may be sorted into three groups: <a href="httpserver.html#start">start()</a> is the do-it-all function (operator()() is a wrapper for <a href="httpserver.html#start">start()</a>), <a href="httpserver.html#readRequest">readRequest()</a>, <a href="httpserver.html#parseRequest">parseRequest()</a>, <a href="httpserver.html#readBody">readBody()</a> and <a href="httpserver.html#respond">respond()</a> contain the bulk of the code and are separated out for proper testing, and the four accessors <a href="httpserver.html#operation">operation()</a>, <a href="httpserver.html#path">path()</a>, <a href="httpserver.html#body">body()</a> and and <a href="httpserver.html#contentLength">contentLength()</a> exist for testing. 
<h2 class="functionh"><a name="HttpServer"></a>HttpServer::HttpServer( int fd, <span class=nobr><a href="init.html">Init</a> &amp; i )</span></h2>
<p class="text">Constructs a new HttpServer for <i>fd,</i> working on <i>i.</i> 
<h2 class="functionh"><a name="body"></a>string HttpServer::body() const</h2>
<p class="text">Returns the client request body, or an empty string if no body was supplied or the request hasn't been parsed yet. 
<h2 class="functionh"><a name="close"></a>void HttpServer::close()</h2>
<p class="text">Closes the socket and updates the state machine as needed. 
<h2 class="functionh"><a name="contentLength"></a>int HttpServer::contentLength() const</h2>
<p class="text">Returns the content-length supplied by the client, or 0 if the client hasn't specified any particular length. 
<h2 class="functionh"><a name="httpResponse"></a>string HttpServer::httpResponse( int numeric, const string &amp; contentType, const string &amp; textual, const string &amp; body )</h2>
<p class="text">Returns a HTTP response string with <i>numeric</i> status, <i>textual</i> explanation (302 Found, etc), <i>contentType</i> and optionally <i>body.</i>
<p class="text">This function does most of what <a href="httpserver.html#send">send()</a> ought to do, but this is easily testable and the same logic in <a href="httpserver.html#send">send()</a> would not be. 
<h2 class="functionh"><a name="operation"></a>Operation HttpServer::operation() const</h2>
<p class="text">Returns the operation specified by the client, or Invalid if there's a parsing problem.
<p class="text">Only Get and Post are recognized now, because those are the only ones our API uses. 
<h2 class="functionh"><a name="operator()"></a>void HttpServer::operator()()</h2>
<p class="text">boost::thread wants to call <a href="httpserver.html#start">start()</a> by this name, so here's a wrapper around <a href="httpserver.html#start">start()</a>. 
<h2 class="functionh"><a name="parseRequest"></a>void HttpServer::parseRequest( string h )</h2>
<p class="text">Parses <i>h</i> as a HTTP request. May set <a href="httpserver.html#operation">operation()</a> to Invalid, but does nothing else to signal errors.
<p class="text">The parser is quite amazingly strict when it does parse, but mostly it doesn't. The client can tell us what Content-Type it wants for the report about its RESTfulness, but we're don't atually care what it says, so we don't even parse its sayings. As I write these words, the only header field we really parse is Content-Length, which is necessary for POST. 
<h2 class="functionh"><a name="path"></a>string HttpServer::path() const</h2>
<p class="text">Returns the path specified by the client, or an empty string in case of parse problems.
<p class="text">The path is local, ie. it starts with a slash.
<p class="text">HttpServer does no canonicalization, but also no file system operations. /a/b/../d is NOT the same as /a/d. 
<h2 class="functionh"><a name="readBody"></a>void HttpServer::readBody()</h2>
<p class="text">Reads a body, for POST.
<p class="text">On return, either <a href="httpserver.html#body">body()</a> will be set, or the <a href="httpserver.html#operation">operation()</a> will be Invalid. 
<h2 class="functionh"><a name="readRequest"></a>string HttpServer::readRequest()</h2>
<p class="text">Reads and returns a single request. Throws nothing.
<p class="text">Aborts after 32k; the common requests will be &lt;500 bytes and practically all &lt;2k, so 32k is a good sanity limit.
<p class="text">
<h2 class="functionh"><a name="respond"></a>void HttpServer::respond()</h2>
<p class="text">Responds to the request, such as it is.
<p class="text">Effectively untestable. Could be separated out into smaller chunks, but I don't care right now. 
<h2 class="functionh"><a name="send"></a>void HttpServer::send( string response )</h2>
<p class="text">Sends <i>response.</i> This function is untested, borderline untestable, which is why it's simple. 
<h2 class="functionh"><a name="start"></a>void HttpServer::start()</h2>
<p class="text">Parses input, acts on it. Returns only in case of error.
<p class="text">This function is not testable. 
<p class="rights">This web page based on source code belonging to <a href="http://arnt.gulbrandsen.priv.no">Arnt Gulbrandsen</a>. All rights reserved.</body></html>
